//#include "type.h"
int open_file(char* pathname, char* mode)
{
    int imode = atoi(mode);
    char ptemp[BLKSIZE], buf[BLKSIZE];
    if (imode < 0 || imode >= 4)
    {
        printf("open_file error: mode not recognized\n");
        return -1;
    }
    char* pathtemp[128];
    strcpy(pathtemp, pathname);

    if(pathname[0] == '/')
    {
        dev = root->dev;
    }
    else
    {
        dev = running->cwd->dev;
    }

    int ino = getino(pathname);

    if(ino == -1) // must creat the file
    {
        strcpy(buf, pathname);
        strcpy(ptemp, dirname(buf));
        int pino = getino(ptemp);
        if(pino == -1)
        {
            printf("open_file error: couldn't find parent inode\n");
            return -1;
        }
        MINODE *pmip = iget(dev, pino);

        mycreat(pathname);
        ino = getino(pathname);
    }

    MINODE *mip = iget(dev, ino);

    if(!S_ISREG(mip->INODE.i_mode))
    {
        printf("open_file error: file is not regular\n");
        return -1;
    }
    OFT *oftp = (OFT *)malloc(sizeof(OFT));
    oftp->mode = mode;
    oftp->refCount = 1;
    oftp->minodePtr = mip;

    switch(imode){
        case 0 : oftp->offset = 0;      // R: offset = 0
                 break;
        case 1 : truncate(mip);         // W: truncate file to 0 size
                 oftp->offset = 0;
                 break;
        case 2 : oftp->offset = 0;      // RW: do NOT truncate file
                 break;
        case 3 : oftp->offset = mip->INODE.i_size;  // APPEND mode
                 break;
        default: printf("invalid mode\n");
                 return(-1);
    }

    int result = -1;

    for (int i = 0; i < NFD; i++)
    {
        if (running->fd[i] == NULL)
        {
            running->fd[i] = oftp;
            result = i;
            break;
        }
        if(running->fd[i]->minodePtr == mip)
        {
            if(imode != 0)
            {
                printf("open_file error: file is already open with incompatible mode\n");
                return -1;
            }
        }
    }

    mip->INODE.i_atime = time(NULL);
    mip->dirty = 1;
    iput(mip);

    return result;
}

int truncate(MINODE* mip){
    //1. release mip->INODEs data block
    // a file may have 12 direct data blocks, 256 indirect data blocks and 256*256
    // double inidirect data blocks. release them all
    //2. update INODE's time field
    //3. set INODE's size to 0 and mark Minode[] dirty
}

int close_file(){
    if (!pathname){
        printf("close_file error: no file name given")
    }
    int fd = atoi(pathname)
    int i;
    OFT *oftp;
    MINODE* mip;
    //1. verify fd is within range.
    
    if (fd<0 || fd >= NFD){
        printf("close_file error: not in range.\n")
    }
    //2. verify running->fd[fd] is pointing at OFT entry
    for (i=0; i < NOFT; i++){
        oftp = &oft[i]; //oft = openfiletable. 
        //I can find where the struct itself is defined in KCs code but i dont think we have an actual variable 
        //also i think open_file is supposed to add every file it opens to this list when we actually create it as
        //a global in main
        if (oftp->inodeptr == running->fd[fd]->inodeptr) break;
        if(i==NOFT-1){
            printf("close_file error: file not pointing at OFT entry.\n")
        }
    }
    //3. The following code segments should be fairly obvious:
    oftp = running->fd[fd];
    running->fd[fd] = 0;
    oftp->refCount--;
    if(oftp->refCount>0) return 0;

    //last user of this OFT entry ==> dispose of the Minode[]
    mip = oftp->inodeptr;
    iput(mip);

    return 0;
}

int lseek(int fd, int position){
    //from fd, find the oft entry

    //change oft entrys offset to position but make sure NOT to over run either end of the file

    //return originalposition
}

int pfd(){
    /*displays the currently opened files as follows
    fd      mode        offset      INODE
    --      ----        ------      -----
    0       READ        1234        [dev,ino]
    1       WRITE       0           [dev,ino]
    -----------------------------------------
    to help users know what files have been opened
    */
    OFT *oftp;
    printf("fd      mode        offset      INODE\n");
    printf("--      ----        ------      -----\n");

    for(int i=0; i < NOFT; i++){
        oftp = &oft[i];
        

    }
}

dup(int fd){
    //verify fd is an opened descriptor
    //duplicates (copy) fd[fd] into FIRST empty fd[] slot
    //increment OFT's refCount by 1
}

dup2(int fd, int gd){
    //CLOSE gd first if its already opened
    //duplicates fd[fd] into fd[gd]
    //increment OFT's refCount by 1;
}