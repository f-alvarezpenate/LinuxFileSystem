//#include "type.h"
int open_file(char* pathname, char* mode)
{
    int imode = atoi(mode);
    char ptemp[BLKSIZE], buf[BLKSIZE];
    if (imode < 0 || imode >= 4)
    {
        printf("open_file error: mode not recognized\n");
        return -1;
    }
    char* pathtemp[128];
    strcpy(pathtemp, pathname);

    if(pathname[0] == '/')
    {
        dev = root->dev;
    }
    else
    {
        dev = running->cwd->dev;
    }

    int ino = getino(pathname);

    if(ino == -1) // must creat the file
    {
        strcpy(buf, pathname);
        strcpy(ptemp, dirname(buf));
        int pino = getino(ptemp);
        if(pino == -1)
        {
            printf("open_file error: couldn't find parent inode\n");
            return -1;
        }
        MINODE *pmip = iget(dev, pino);

        mycreat(pathname);
        ino = getino(pathname);
    }

    MINODE *mip = iget(dev, ino);

    if(!S_ISREG(mip->INODE.i_mode))
    {
        printf("open_file error: file is not regular\n");
        return -1;
    }
    OFT *oftp = (OFT *)malloc(sizeof(OFT));
    oftp->mode = imode;
    oftp->refCount = 1;
    oftp->minodePtr = mip;

    switch(imode){
        case 0 : oftp->offset = 0;      // R: offset = 0
                 break;
        case 1 : truncate(mip);         // W: truncate file to 0 size
                 oftp->offset = 0;
                 break;
        case 2 : oftp->offset = 0;      // RW: do NOT truncate file
                 break;
        case 3 : oftp->offset = mip->INODE.i_size;  // APPEND mode
                 break;
        default: printf("invalid mode\n");
                 return(-1);
    }

    int result = -1;

    for (int i = 0; i < NFD; i++)
    {
        if (running->fd[i] == NULL)
        {
            running->fd[i] = oftp;
            result = i;
            break;
        }
        if(running->fd[i]->minodePtr == mip)
        {
            if(imode != 0)
            {
                printf("open_file error: file is already open with incompatible mode\n");
                return -1;
            }
        }
    }
    OFT *temp;
    //add file to oft array
    for (int i = 0; i < NOFT; i++){
        temp = &oft[i];
        if (temp->refCount==0){
            temp->mode = oftp->mode;
            temp->minodePtr = oftp->minodePtr;
            temp->refCount = oftp->refCount;
            break;
        }
        else if (i == NOFT - 1){
            printf("open_file error: Too many files opened at once.\n");
            iput(mip);
            return;
        }
    }
    mip->INODE.i_atime = time(NULL);
    mip->dirty = 1;
    iput(mip);

    return result;
}

int truncate(MINODE* mip){
    //1. release mip->INODEs data block
    // a file may have 12 direct data blocks, 256 indirect data blocks and 256*256
    // double inidirect data blocks. release them all
    //2. update INODE's time field
    //3. set INODE's size to 0 and mark Minode[] dirty

    char buf12[BLKSIZE], buf13[BLKSIZE]; 
    INODE *ip = &mip->INODE;

    for (int i = 0; i < 12; i++) // 12 first direct blocks
    {
        if(ip->i_block[i] == 0)
        {
            break;
        }

        bdalloc(dev, ip->i_block[i]);
        ip->i_block[i] = 0;
    }

    if(ip->i_block[12] != NULL) // first indirect blocks
    {
        get_block(dev, ip->i_block[12], buf12);
        int* buf_ref12 = (int *) buf12;

        for (int i = 0; i < BLKSIZE / sizeof(int); i++)
        {
            if(buf_ref12[i] == 0)
            {
                break;
            }
            bdalloc(dev, buf_ref12[i]);
            buf_ref12[i] = 0;
        }
        bdalloc(dev, ip->i_block[12]);
        ip->i_block[12] = 0;
    }

    if(ip->i_block[13] != NULL) // doubly indirect blocks need to be dealt with
    {
        get_block(dev, ip->i_block[13], buf13);
        int* buf_ref13 = (int *)buf13;
        for(int i = 0; i < BLKSIZE / sizeof(int); i++)
        {
            if(buf_ref13[i] == 0)
            {
                break;
            }
            bdalloc(dev, buf_ref13[i]);
            buf_ref13[i] = 0;
        }

        bdalloc(dev, ip->i_block[13]);
        ip->i_block[13] = 0;
    }

    mip->INODE.i_blocks = 0;
    mip->INODE.i_size = 0;
    mip->dirty = 1;
    iput(mip);

}

int close_file(){
    if (!pathname){
        printf("close_file error: no file name given");
    }
    int fd = atoi(pathname);
    int i;
    OFT *oftp;
    MINODE* mip;
    //1. verify fd is within range.
    
    if (fd<0 || fd >= NFD){
        printf("close_file error: not in range.\n");
    }
    //2. verify running->fd[fd] is pointing at OFT entry
    for (i=0; i < NOFT; i++){
        oftp = &oft[i]; //oft = openfiletable. 
        if (oftp->minodePtr == running->fd[fd]->minodePtr) break;
        if(i==NOFT-1){
            printf("close_file error: file not pointing at OFT entry.\n");
        }
    }
    //3. The following code segments should be fairly obvious:
    oftp = running->fd[fd];
    running->fd[fd] = 0;
    oftp->refCount--;
    if(oftp->refCount>0) return 0;

    //last user of this OFT entry ==> dispose of the Minode[]
    mip = oftp->minodePtr;
    iput(mip);

    return 0;
}

// int lseek(int fd, int position){
//     //from fd, find the oft entry

//     //change oft entrys offset to position but make sure NOT to over run either end of the file

//     //return originalposition
// }

int pfd(){
    /*displays the currently opened files as follows
    fd      mode        offset      INODE
    --      ----        ------      -----
    0       READ        1234        [dev,ino]
    1       WRITE       0           [dev,ino]
    -----------------------------------------
    to help users know what files have been opened
    */
    OFT *oftp;
    printf("fd      mode        offset      INODE\n");
    printf("--      ----        ------      -----\n");

    for(int i=0; i < NOFT; i++){
        oftp = &oft[i];
        if(oftp->refCount != 0){
            printf("%d    ", i);
        
            switch(oftp->mode){
                case 0: 
                    printf("   READ");
                    break;
                case 1:
                    printf("   WRITE");
                    break;
                case 2:
                    printf("   READ/WRITE");
                    break;
                case 3:
                    printf("   APPEND");
                    break;
            }
            printf("     %6d         [%d,%d]\n", oftp->offset, oftp->minodePtr->dev, oftp->minodePtr->ino);
        }
        else{
            break;
        }
        printf("-------------------------------------------\n");
    }
    return 0;
}

dup(int fd){

    if (running->fd[fd] == NULL)
    {
        printf("dup error: fd is not an open descriptor\n");
    }
    
    OFT *oftp = running->fd[fd];
    for(int i = 0; i < NFD; i++)
    {
        if(running->fd[i] == NULL)
        {
            running->fd[i] = oftp;
            oftp->refCount++;
            return 0;
        }
    }

}

dup2(int fd, int gd){
    
    if (running->fd[gd] != NULL) // needs to be closed
    {
        close_file(gd);
    }
    
    OFT *oftp = running->fd[fd];
    running->fd[gd] = oftp;
    oftp->refCount++;
    return 0;

}
